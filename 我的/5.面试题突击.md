# 面试题精简突击



## 1. String ,StringBuffer,StringBuilder区别

| String                         | StringBuffer | StringBuilder            |
| ------------------------------ | ------------ | ------------------------ |
| 不可变，修改生成新的字符串对象 | 可变         | 可变                     |
| 线程安全                       | 线程安全     | 线程不安全，单线程效率高 |



## 2. ArrayList 和 LinkedList 区别

| ArrayList                          | LinkedList                                     |
| ---------------------------------- | ---------------------------------------------- |
| 基于数组实现                       | 基于双向链表实现                               |
| 适合频繁随机访问，频繁尾部插入删除 | 适合频繁中间位置插入删除                       |
| 实现List接口                       | 实现List接口、额外实现 Deque接口可以当队列使用 |



## 3. CopyOnWriteArrayList 底层原理

线程安全，**写时复制**，内部通过数组实现，写操作时可读取数据，适合读多写少的场景，但是内存占用高，读不到实时数据

添加元素时，复制一个新的数组，在**新的数组上写**操作，在**原来的数组上读**操作

写操作加锁，防止并发写入丢失数据

写操作完毕后，把原数组指向新数组，



## 4. HashMap 扩容机制原理

**1.7版本**

生成新数组，遍历老数组中每个位置上的链表的元素

取出每个元素上的key，基于新数组长度，计算每个元素在新数组中的下标

转移所有元素到新数组中，完成后，将新数组赋值给HashMap的table属性

**1.8版本**

生成新数组，遍历老数组中每个位置上的链表或者红黑树的元素

是链表，重新计算链表元素在新数组中的下标，转移到新数组中

是红黑树，遍历红黑树，重新计算红黑树中每个元素在新数组中的下标位置

​	a. 统计每个下标位置的元素个数

​	b. 该位置元素 >8个，则生成新的红黑树，并将红黑树的根节点添加到新数组的对应位置

​	c. 该位置元素 <=8个, 则生成新的链表，并将链表的头节点添加到新数组的对应位置

所有元素转移完后，将新数组赋值给HashMap的table属性



## 5. ConcurrentHashMap 扩容机制原理

**1.7版本**

基于segment分段实现

每个segment相当于一个小型的HashMap

每个segment内部会扩容，和HashMap扩容机制类似

生成新数组，转移元素到新数组中

扩容判断是segment内部独自判断是否超过阈值

**1.8版本**

不在基于segment实现

当线程put时，发现正在进行扩容，则该线程一起进行扩容

当线程put时，发现没有进行扩容，则将key-value添加到ConcurrentHashMap中，如果超过阈值，则进行扩容

支持多个线程同时扩容

生成新的数组，将原数组分组，将每个分组分给不同的线程进行元素转移，每个线程负责一组或者多组元素转移



## 6. 





















































































































































































